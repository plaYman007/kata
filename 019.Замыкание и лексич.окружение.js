"use strict";

let number = 5;

function ass() {
  console.log(number);
}
number = 6;
ass();
//Важно! В таком случае значение будет 6, т.к. внутри функции нет присвоения переменной.
//Мы выводим в консоль некую переменную, которая существует ЗА пределами функции.
//ЕСЛИ ВНУТРИ ФУНКЦИИ ПРОПИСАТЬ number=4 - соответствнено, консоль выдаст результат 4.
//Это и есть замыкание функции - когда функция ищет значение сначала внутри себя, ЛОКАЛЬНО. И если его не находит - обращается ко внешнему коду.

function createCounter() {
  let counter = 0;
  const myFunction = function () {
    counter = counter + 1;
    return counter;
  };
  return myFunction;
}

const increment = createCounter();
const c1 = increment();
const c2 = increment();
const c3 = increment();
console.log(c1, c2, c3);
/*Охх бля, поехали. Учимся читать правильно.
Сначала мы создаем переменную createCounter, мы ей присваиваем глобальную функцию.
Далее мы создаем переменную increment, которой присваиваем функцию createCounter(). Пока что значение у increment - undefiend
Далее мы создаем переменную counter со значением 0. 
Далее мы создаем новую функцию, с новой переменной myFunction,изначально у неё будет значение undefiend, а после этого в него помещается функция.
Далее мы присваиваем значение counter и создаем замыкание функции - return counter, т.е. возвращаем это значение.
Далее мы возвращаем содержимое переменной myFunction. Т.е. мы уничтожаем её локальное значение, и выводим его наружу.
Далее всё это попадет в переменную increment. В том числе и замыкание этой функции.
Далее мы создаем переменную c1 со значением undefiend, далее вызываем increment;
!!! Далее, тут пиздец важно - мы вызываем саму функцию increment, т.е. перемещаемся внутрь функции createCounter, а точнее - в самую её глубь, на conter = counter+1;
Соответственно, сначала считается 0 + 1, это будет единица, затем это записывается в функцию, и затем уже переходит в c1. ПРИ ЭТОМ МЫ ВОЗВРАЩАЕМ ФУНКЦИИ ЗНАЧЕНИЕ 1, НЕ НОЛЬ!!
Далее, соответственно, с2 - тут тоже самое. Только значение counter уже изначально будет 1. Соответственно, 1+1 будет 2.